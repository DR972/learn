Home Task Algorithmization: Questions.

1. Массив в Java - это наиболее эффективный способ организации размещения последовательности объектов (ссылок на объекты) одного типа и произвольного доступа к ним.
   Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку).
   Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют индексом.
   Индексация элементов массива начинается с 0, поэтому, чтобы обратиться к i-му элементу в массиве, нам надо использовать выражение nums[i-1].
   В Java массивы являются объектами. Это значит, что имя, которое даётся каждому массиву, лишь указывает на адрес какого-то фрагмента данных в памяти.
   Кроме адреса в этой переменной ничего не хранится.

2. Объявление массива:
	dataType[] arrayName;	примеры: int[] myArray;(для примитивных типов)	Object[] arrayOfObjects;(для ссылочных типов)
		или
	dataType arrayName[];	примеры: int myArray[];(для примитивных типов)	Object arrayOfObjects[];(для ссылочных типов)
   Инициализация массива:
	myArray = new int[4]; массив из 4 элементов int и все они = 0 	myArray = new int[] {1,2,5,8};
   Объявление и инициализация массива одновременно:
	int[] myArray = new int[4];	или 	int[] myArray = new int[] {1,2,5,8};
   Объявление и инициализация двумерных массивов:
	int[][] myArray = new int[3][4]; или	int [][] myArray = {{5,7,3,17}, {7,0,1,12}, {8,1,2,3}};
	Object[][] arrayOfObjects = {{new Object(), new Object()}, {new Object(), new Object(), new Object()};
   Примитивные типы хранят значения, ссылочные ссылку на объект.

3. Методы копирования массива в Java:
	Object.clone() — можно использовать этот метод для полного копирования массива. Этот метод не подойдет, если вы хотите частично скопировать массив.
	System.arraycopy() — лучший способ сделать частичную копию массива. В методе определены такие параметры:
		массив, элементы которого будем копировать;
		с какого индекса копировать элементы;
		результирующий массив;
		первый элемент результирующего массива и общее количество элементов для копирования.
			Например System.arraycopy(источник, 3, назначения, 2, 5) — будет скопировано 5 элементов из массива-источника в результирующий массив,
			начиная с 3-го индекса источника во 2 индекс результирующего массива.
	Arrays.copyOf() — этот метод используется, если надо скопировать несколько первых элементов массива или сделать полную копию.
		Но он не такой универсальный, как System.arraycopy().
		Например int[] S2 = Arrays.copyOf(S1, длина) — будет создан массив S2 из S1. Если S2<S1, то лишнее игнорируется. Если S2>S1, заполняется нулями.
	Arrays.copyOfRange() — этот метод используется, если надо скопировать конкретные подряд идущие элементы.
		Например int[] S2 = Arrays.copyRange(S1, 3, 8) - будет создан массив S2 из S1, в него попадут элементы с 3 по 8.
	Все эти методы для копирования доступны только для одномерных массивов.

	По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.
	При клонировании, JVM делает такие вещи:   
		1. Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
		2. Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов.
			Следовательно, оба объекта будут иметь одинаковые ссылки.

4. Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий массив. Но гораздо проще его представить в виде таблицы,
   у которой задано количество строк (первое измерение) и количество столбцов (второе измерение). Двумерный массив, у которого все строки имеют равное количество
   элементов, называется прямоугольным.
   Поскольку в Java двумерные массивы — это массивы массивов, каждый из внутренних массивов может быть разной длины.
   Зубчатый массив в Java - это многомерный массив, содержащий в качестве элементов массивы различных размеров. Он также называется «рваным массивом». Например 
	int[][] myArray = new int [3][];
	myArray[0] = new int[]{5,7};		// в строке 0 - 2 элемента
	myArray[1] = new int[]{7,1,12};		// в строке 1 - 3 элементов
	myArray[2] = new int[]{8,1,2,3};	// в строке 2 - 4 элемента

5. Исключение ArrayIndexOutOfBoundsException возникает, когда программа пытается адресовать элементы за пределами массива.
	Появляется, чтобы указать, что к массиву был обращен незаконный индекс. Индекс является либо отрицательным, либо большим или равным размеру массива.
   Исключение ArrayStoreException возникает, когда программа пытаться записать в ячейку массива ссылку на объект неправильного типа.
	Компилятор гарантирует, что берется элемент из массива, он будет представителем типа элементов самого этого массива. Не важно какого типа переменная
	его хранит. Именно для обеспечения этой гарантии работает проверка типа времени выполнения, которая и выбрасывает ArrayStoreException.

6. Чтобы сделать код более расширяемым, логичным и читабельным. Когда разработчик создаёт приложение, руководствуясь плохой архитектурой, 
   код получается негибким, даже небольшие изменения в нём могут привести к багам.

7. Параметры в методы java передаются по значению (копируются). У примитивных типов это само значение. Ссылочные типы своим значением хранят ссылку на объект в памяти.
   Соответственно, у примитивных типов копируется значение, а у ссылочных типов копируется ссылка на объект. Это означает, что когда метод возвращается, переданная 
   ссылка по-прежнему ссылается на тот же объект, что и раньше. Однако значения полей объекта могут быть изменены в методе, если они имеют соответствующий уровень доступа.
   Параметрам, объявленным как final в методе нельзя изменить или присвоить новое значение. Соответственно, ссылочным объектам мы не можем присвоить другую ссылку 
   данной переменной, но мы по прежнему можем изменять состояние объекта, если у нас есть соответствующие разрешения.

8. Поскольку массив является объектом, то в метод он передается по ссылке. И возвращается соответственно тоже по ссылке.
   Изменить размер массива нельзя, можно только создать новый.

9. Методы в Java — это по сути подпрограммы. Их задача провести опреленные манипуляции с данными.
   Метод void не возвращает значания, а только проводит манипуляции.
   Если метод возвращает какие-то данные, то в теле метода используется оператор return значение, где значение - это возвращаемое значение.
   У примитивных типов возвращается значение, а у ссылочных типов - ссылка на объект.

10. Алгоритмы сортировки.
    1. Сортировка пузырьком или Bubble sort.
	Пузырьковая сортировка сравнивает соседние элементы и меняет местами если они не отсортированы.
	for (int i = 0; i < arr.length - 1; i++) {
		for (int j = 0; j < arr.length - i - 1; j++) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
    2. Сортировка вставками или Insertion Sort.
	Сортировка вставками работает, проходя по массиву и перемещая нужное значение в начало массива. После того, как обработана очередная позиция,
	мы знаем, что все позиции до нее отсортированы, а после нее — нет.
	int key;
	for (int i = 1; i < arr.length; i++) {
		key = arr[i];
		int j = i - 1;
		while (j >= 0 && arr[j] > key) {
			arr[j + 1] = arr[j];
			j --;
		}
		arr[j + 1] = key;
	}
    3. Сортировка выбором или Selection Sort.
	Сортировка выбором представляет собой механизм сортировки, который начинается с поиска наименьшего элемента в массиве и размешение его первым.
	Затем находится второй наименьший элемент и размещается вторым, и так до тех пор пока весь массив не отсортируется.
	for (int i = 0; i < arr.length; i++) {
		int pos = i;
		int min = arr[i];            
		for (int j = i + 1; j < arr.length; j++) {
			if (arr[j] < min) {
			pos = j; 
			min = arr[j];
			}
		}
		arr[pos] = arr[i];
		arr[i] = min;
	}
    4. Сортировка методом Шелла.
	Эта сортировка является обобщением сортировки вставкой, что позволяет осуществлять обмен элеметов, которые находятся далеко друг от друга.
	Она начинается, сравнивая элементы, которые далеки друг от друга, и постепенно уменьшает растояние между сравниваемыми элементами.
	Время работы меняется в зависимости от последовательности промежутков используемых для сортировки элементов.
	for (int step = arr.length / 3; step > 0; step /= 3) {
		for (int i = step; i < arr.length; i++) {
			for (int j = i - step; j >= 0 && arr[j] > arr[j + step] ; j -= step) {
				int x = arr[j];
  				arr[j] = arr[j + step];
				arr[j + step] = x;
			}
		}
	}  