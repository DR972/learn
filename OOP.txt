OOP, Classes and Objects, Inheritance, Class Object, Interfaces

1. Объектно-ориентированное программирование (ООП) — это методология программирования, основанная на представлении программы в виде совокупности объектов,
   каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования. Основными принципами ООП являются:
		абстракция;
		инкапсуляция;
		наследование;
		полиморфизм.
	Абстракция –  означает выделение значимой информации и исключение из рассмотрения незначимой. С точки зрения программирования это правильное разделение программы на объекты.
   Абстракция позволяет отобрать главные характеристики и опустить второстепенные. Пример: описание должностей в компании. Здесь название должности значимая информация,
   а описание обязанностей у каждой должности это второстепенная информация. К примеру главной характеристикой для "директор" будет то, что это должность чем-то управляет,
   а чем именно (директор по персоналу, финансовый директор, исполнительный директор) это уже второстепенная информация.
	Инкапсуляция – свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Для Java корректно будет говорить, что инкапсуляция это "сокрытие реализации".
   Пример из жизни – пульт от телевизора. Мы нажимаем кнопочку "увеличить громкость" и она увеличивается, но в этот момент происходят десятки процессов, которые скрыты от нас.
   Для Java: можно создать класс с 10 методами, например вычисляющие площадь сложной фигуры, но сделать из них 9 private. 10-й метод будет называться "calculateArea()" и объявлен public,
   а в нем уже будут вызываться необходимые скрытые от пользователя методы. Именно его и будет вызывать пользователь.
	Наследование – свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого
   производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом. При этом новый класс сохраняет
   все свойства старого: данные объекта базового класса включаются в данные объекта производного, а методы базового класса могут быть вызваны для объекта производного класса, причем
   они будут выполняться над данными включенного в него объекта базового класса. Иначе говоря, новый класс наследует как данные старого класса, так и методы их обработки. Если объект
   наследует свои свойства от одного родителя, то говорят об одиночном наследовании. Если объект наследует данные и методы от нескольких базовых классов, то говорят о множественном
   наследовании.
	Полиморфизм – свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
	public interface Shape {
		void 
		void erase();
	}
	public class Circle implements Shape {
		public void draw() {
			System.out.println("Circle.draw()");
    		}
	}
	public class Triangle implements Shape {
		public void draw() {
			System.out.println("Triangle.draw()");
		}
	}
 	public class TestPol {
		public static void main(String[] args) {
			Shape shape1 = new Circle();
			Shape shape2 = new Triangle();
			testPoly(shape1);
			testPoly(shape2);
		}
 		public static void testPoly(Shape shape) {
        		shape.draw();
		}
	}
	//Вывод в консоль:
	//Circle.draw()
	//Triangle.draw()
   Есть общий интерфейс "Shape" и две его реализации "Triangle" и "Circle". У каждого есть метод "draw()". Благодаря полиморфизму нам нет нужды писать отдельный метод для каждой из
   множества фигур, чтобы вызвать метод "draw()".  Вызов полиморфного метода позволяет одному типу выразить свое отличие от другого, сходного типа, хотя они и происходят от одного
   базового типа. Это отличие выражается различным действием методов, вызываемых через базовый класс (или интерфейс). Здесь приведен пример полиморфизма (также называемый динамическим
   связыванием, или поздним связыванием, или связыванием во время выполнения), в котором продемонстрировано как во время выполнения программы будет выполнен тот метод, который 
   принадлежит передаваемому объекту. Если бы не было полиморфизма и позднего связывания, то для каждого класса (фигуры) мы бы писали отдельный метод:
	public static void testPolyCircle(Circle circle) {
		circle.draw();
	}
	public static void testPolyTriangle(Triangle triangle) {
		triangle.draw();
	}

2.  Инициализация (от англ. initialization - инициирование) - создание, активация, подготовка к работе, определение параметров.
   Порядок инициализации:
	инициализации статических переменных (полей) класса-предка;
	инициализации статических переменных (полей) класса-потомка;
	инициализации нестатических переменных (экземпляров класса) класса-предка;
	инициализации нестатических полей (экземпляров класса) класса-потомка.
   Типы инициализации полей класса:
	инициализация в месте объявления;
	инициализация в статическом блоке.
   Типы инициализации полей экземпляра класса:
	инициализация в месте объявления;
	инициализация в нестатическом блоке;
	инициализация через конструктор.
   Всем числовым переменным по умолчание присваивается '0', переменной char - ' '(нуль-символ), переменной boolean  - 'false', ссылочным переменным - 'null'.   

3. Java bean - это классы хранители информации. Свойства Java bean классов:
	1. Наличие модификатора public.
	2. Присутствие Дефолтного(без аргументов) public конструктора.
	3. Поля должны быть нестатическими и private.
	4. Для доступа к полям должны быть корректно определены set и get методы.
	5. Возможность сохраняемости (serializable).
	6. Equals и hashcode реализация, а также toString для предоставления информации в строковом виде.

	import java.io.Serializable;
	import java.util.StringJoiner;

	public class Order implements Serializable {
		private long orderId;
		private double amount;

		public Order() {}

		public Order(long orderId, double amount) {
			this.orderId = orderId;
			this.amount = amount;
		}

		public long getOrderId() {return orderId;}

    		public void setOrderId(long orderId) {this.orderId = orderId;}

		public double getAmount() {return amount;}

		public void setAmount(double amount) {this.amount = amount;}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Order order = (Order) o;
			if (orderId != order.orderId) return false;
			return Double.compare(order.amount, amount) == 0;
		}

		@Override
		public int hashCode() {
			int result;
			long temp;
			result = (int) (orderId ^ (orderId >>> 32));
			temp = Double.doubleToLongBits(amount);
			result = 31 * result + (int) (temp ^ (temp >>> 32));
			return result;
		}

		@Override
		public String toString() {
			return new StringJoiner(", ", Order.class.getSimpleName() + "[", "]")
			.add("orderId=" + orderId)
			.add("amount=" + amount)
			.toString();
		}
	}

4. Перегрузка (от англ. overloading) - использование одного идентификатора для ссылки на разные элементы в одной области действия.
   Перегрузка методов — это приём программирования, который позволяет разработчику в одном классе для методов с разными параметрами использовать одно и то же имя.
   В этом случае говорят, что метод перегружен. Каждый перегруженный метод должен иметь уникальный список типов аргументов.
   Главная ценность перегрузки заключается в том, что она обеспечивает доступ к группе родственных методов по общему имени.
   Использование перегрузки делает код чище и проще для чтения, а также помогает избежать ошибок в программе.
   Статические методы могут перегружаться нестатическими и наоборот – без ограничений.
   Перегрузка метода определяет несколько методов в одном классе, которые принимают разные числа и типы параметров. Перегрузка возможна также из базового класса.
   Перегрузка конструкторов реализуется так же, как и перегрузка методов. Перегрузка конструкторов позволяет установить различные способы начальной инициализации объектов класса.
   При перегрузке конструкторов менять атрибуты доступа у конструкторов нельзя.

5. Возможность связать конкретный вызов метода с телом метода называется связыванием.
   Раннее связывание - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода.
   Позднее связывание - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.
   Перегрузка – это раннее связывание.
   Правила перегрузки методов:
	1. Список параметров должен быть разным.
	2. Статический тип должен быть разным.
	3. Расширяющее преобразование примитивов имеет приоритет над автоупаковкой/распаковкой.
	4. Автоупаковка/распаковка имеет приоритет перед методом с переменным количеством аргументов.
	5. Сужающее преобразование примитивов автоматически НЕ выполняется.

6. Ключевое слово this используется для ссылки на текущий экземпляр метода, в котором он используется. Способы его использования:
	1. Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена, чтобы конкретно обозначить, что переменная экземпляра 
		используется вместо статической или локальной переменной:
			private String javaFAQ;
			void methodName(String javaFAQ) {
    				this.javaFAQ = javaFAQ;
			}
	2. Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого:
			Human(int age, int weight){
        			this.age = age;
        			this.weight = weight;
    			}
    			Human(int age, int weight, int height){
				this(age, weight);
				this.height = height;
			}
	3. Для передачи текущего экземпляра java в качестве параметра:
			obj.itIsMe(this);
	4. Может быть использовано для возврата текущего экземпляра:
			CurrentClassName startMethod() {
     				return this;
			}
	5. This можно использовать для получения дескриптора текущего класса:
			Class className = this.getClass();
   Ключевое слово this представляет собой неявно определенный указатель на сам объект. С его помощью метод класса определяет, с данными какого объекта ему предстоит работать.
   По идеи оно должно присутствовать перед каждым объектом в методе, но это очень неудобно. Поэтому за нас это делает компилятор.
   this присутствует в обычных методах, но её нет в статических методах, потому что там нет экземпляра класса, соответсвенно this не может к нему обратиться.

7. Ключевое слово final может применяться к классам, методам или полям. 
   В применении к классу оно означает, что данный класс не может подразделяться на подклассы. 
   В применении к методу оно означает, что данный метод не может быть заменен каким-либо подклассом. 
   В применении к полю, оно означает, что в каждом конструкторе значение поля должно задаваться только один раз и после этого никогда не может изменяться.
   Поле final является полем, предназначенным только для чтения, и гарантируется, что его параметры задаются только один раз во время построения или во время инициализации 
   класса для static (статических) final полей.

8. Поле данных, объявленное в классе как static, является общим для всех объектов класса и называется переменной класса. Если один объект изменит значение такого поля,
   то это изменение увидят все объекты. Применив определение final к статической переменной получим константу, что очень удобно.
   Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту. 
   Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам.
   Переопределение статических методов класса не имеет практического смысла, так как обращение к статическому атрибуту или методу осуществляется по большей части 
   посредством задания имени класса, которому они принадлежат.
   Статические методы могут быть перегружены нестатическими, как было указано в п.4.
   Статические методы в Java наследуются, но не могут быть переопределены. Если вы объявляете тот же метод в подклассе, вы скрываете метод суперкласса вместо его переопределения.
   Статические методы не являются полиморфными. Во время компиляции статический метод будет статически связан.

9. Есть два блока инициализации — обычный и статический.
   Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же не статический, соответственно,
   им задают статические переменные (то есть переменные класса).
   Статический блок в java выполняется перед основным методом. Их может сколько угодно и располагаться могут в любом месте класса.
   Обычный блок должен быть расположен перед созданием объекта.

10. Возникают ситуации, когда заранее неизвестно количество передаваемых экземпляров класса в метод. В обычной ситуации пришлось бы создавать несколько перегруженных методов
   с разным числом параметров одного типа. Другим решением будет один метод с параметром в виде массива или коллекции.В методах этого типа список параметров имеет
   не фиксированную, а переменную длину.
			static void test(int... array) {}
   Это объявление сообщает компилятору, что метод test() может вызываться с указанием произвольного количества аргументов или без них. Оно также означает неявное
   объявление аргумента array в виде массива int[]. Помимо списка параметров переменной длины, в объявлении метода могут быть указаны и обычные параметры при условии:
   список параметров переменной длины можно указать только один раз и он должен быть указан последним.
   Дальнейшая работа с этими методами аналогична работе с обычными методами.

11. В Java определен один специальный класс, называемый Object. Все остальные классы являются подклассами, производными от этого класса,
   даже если в объявлении это явно не указано. В классе Object определен ряд методов, которые доступны всем классам языка Java.
   Методы класса Object в Java:
	1. protected Object clone() - создает новый объект, не отличающийся от клонируемого;
	2. protected void finalize() - вызывается перед удалением неиспользуемого объекта;
	3. public final Class<?> getClass() - получает класс объекта во время выполнения;
	4. public int hashCode() - возвращает хэш-код, связанный с вызывающим объектом;
	5. public final void notify() - возобновляет исполнение потока, ожидающего вызывающего объекта;
	6. public final void notifyAll() - возобновляет исполнение всех потоков, ожидающих вызывающего объекта;
	7. public String toString() - возвращает символьную строку, описывающую объект;
	8. public final void wait() - ожидает другого потока исполнения;
	9. public final void wait(long timeout) - ожидает другого потока исполнения;
	10. public final void wait(long timeout, int nanos) - ожидает другого потока исполнения;
	11. public boolean equals(Object obj) – сравнивает объекты.

12. Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной длины для любого объекта.
    В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int.     
    Если надо сравнивать объекты, гораздо проще сделать это по хэш-коду, и только если они равны по hashCode() — переходить к сравнению по equals().
    Для метода hashCode() есть официальные требования, прописанные в документации Oracle:
	1. Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.
	2. Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число.
	3. Правило 1 не работает в обратную сторону. Одинаковый хэш-код может быть у двух разных объектов.
    Ситуация, когда два разных объекта могут сгенерировать одинаковые хэш-коды называется коллизией.
    Например, если хешировать целые числа и хеширующая функция просто (n % 10) то число 17 и число 27 приведут к одинаковому результату. Это не значит, что эти цифры одинаковы.
    Поэтому, после если два объекта равны по hashCode() — переходим к сравнению по equals().

13. Наследование – свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого
   производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом. При этом новый класс сохраняет
   все свойства старого: данные объекта базового класса включаются в данные объекта производного, а методы базового класса могут быть вызваны для объекта производного класса, причем
   они будут выполняться над данными включенного в него объекта базового класса. Иначе говоря, новый класс наследует как данные старого класса, так и методы их обработки.
   Правила наследования:
	1. Наследуется только один класс. Java не поддерживает наследование нескольких классов. Один класс - один родитель. Нельзя наследовать самого себя!
	2. Наследуется все кроме приватных переменных и методов. Говорят класс-наследник имеет доступ ко всем переменным и методам родителя. Это не совсем так.
		На самом деле, все методы и переменные, помеченные модификатором private, не доступны классу-наследнику.
	3. Переопределение метода класса-родителя. Представим, что мы наследуем класс, но нам нравится не все, что мы унаследовали. Допустим мы хотим, чтобы определенный метод работал
   		не так, как в родителе. Для того, чтобы переопределить метод класса-родителя, пишем над ним @Override:
		Действует общий принцип: расширять видимость можно, сужать нельзя. private методы видны только внутри класса, для потомков они не видны. Поэтому их и расширить нельзя.
	4. Вызыов методов родителя осуществляется через ключевое слово super. Если надо изменить метод родительского класса совсем чуть-чуть - буквально дописать пару строк. 
		Тогда в своем методе мы можем вызвать родительский метод с помощью ключевого слова super.
	5. Запрет наследования. Если не хотите, чтобы кто-то наследовал Ваш класс, поставьте перед ним модификатор final.

	public class Program{
		public static void main(String[] args) {
			Person tom = new Person("Tom");
			tom.display();
			Person sam = new Employee("Sam", "Oracle");
			sam.display();
    		}
	}

	class Person {
		private String name;
		public String getName() {
			return name;
		}
		public Person(String name){
			this.name=name;
		}
		public void display() {
			System.out.printf("Person %s \n", name);
		}
	}
 
	class Employee extends Person {
		private String company;
		public Employee(String name, String company) {
			super(name);
			this.company = company;
		}

		@Override
		public void display() {
			System.out.printf("Employee %s works in %s \n", super.getName(), company);
		}
	}

14. В конструкторе дочернего класса, перед тем как будут выполнены выражения тела, неявно вызывается дефолтный (без параметров) конструктор предка.
   Причем конструктор без параметров обязательно должен быть в родительском классе, если в дочернем предполагаются только конструкторы с аргументами, а родительские 
   конструкторы не вызываются явно. В этом случае, если в родительском классе будут только конструкторы с аргументами, то в дочернем будет возникать ошибка.
   Другой распространенный вариант – когда в дочернем классе явно вызывается конструктор родительского класса с помощью ключевого слова super.
   Причем вызывать всегда надо первой строчкой тела конструктора.
   В одном конструкторе можно использовать операторы super() и this(), только super() обязательно должен быть в первой строчке.
	class Parent {
		int a;
		Parent(int a) {
		this.a = a;
		}
	}
	class Child extends Parent {
    		int b;
    		Child(int a, int b) {
        		super(a);
        		this.b = b;
		}
	}

15. Ссылочная переменная родительского класса может ссылаться на объект подкласса (на том основании, что экземпляры производного класса являются разновидностями базового).
	class Point {
		public int x, int y;
	}
	class Point3D extends Point {
		public int z;
	}
	public class Main {
    		public static void main(String[] args) {
			Point Pobj = new Point();
			Point3D Cobj = new Point3D();
			Pobj = Cobj;
			Pobj.x = 1;
		}
	}

   Допустим, мы пишем класс D (derived, производный), который открыто наследуется от класса B (base, базовый). Создавая такую иерархию классов, мы тем самым сообщаем компилятору,
   что каждый объект типа D является также объектом типа B, но не наоборот. Мы говорим, что B представляет собой более общую концепцию чем D, а D — более конкретную концепцию,
   чем B. Мы утверждаем, что везде, где может быть использован объект B, можно использовать также объект типа D, потому что D является объектом типа B. 
   С другой стороны, если нам нужен объект типа D, то объект B не подойдет, поскольку каждый D «является разновидностью» B, но не наоборот.
   В качестве примера будем использовать понятия человека и студента. Каждый студент является человеком, поэтому человек будет базовым классом, а студент — производным.
	public class People {
		public static void main(String[] args) {
			Person person = new Person();
			Student student = new Student();
			person.eat(); // person все люди могут есть
			student.eat(); // student все люди могут есть
			student.study(); // student учится
			person.study(); // Cannot resolve method 'study' in 'Person' person не student
		}
	}

	class Person {
		String p = "person";
		static void eat() {System.out.println("все люди могут есть");}
	}
	class Student extends Person {
    		String s = "student";
		static void study() {System.out.println("учится");}
	}
   Таким образом объект производного класса может быть использован везде, где ожидается объект его базового типа. Обратно никак.

16-17. Если в иерархии классов сигнатура (тип возврата, тип параметров, количество параметров и порядок параметров) метода класса-наследника совпадает с сигнатурой метода
   родительского класса, то метод подкласса переопределяет метод базового класса. Вызов переопределённого метода из своего подкласса всегда ссылается на версию,
   определённую подклассом, а версия метода родительского класса будет скрыта. Чтобы вызвать «переопределенный» метод родительского класса следует использовать super.
   Преимущество в Java переопределения заключается в том, что оно позволяет определять (описывать) поведение, характерное для типа подкласса, значит подкласс может
   реализовать метод родительского класса на основе его требования.
   Правила переопределения метода:
	1. Список аргументов должен быть точно таким же, как и для переопределённого метода.
	2. Возвращаемый тип должен быть таким же или подтипом возвращаемого типа, объявленного в исходном переопределенном методе в суперклассе.
	3. Уровень доступа не может быть более ограниченным, чем уровень доступа переопределённого метода. Например, если метод суперкласса объявлен public, 
		то переопределяемый метод в подклассе не может быть private или protected.
	4. Методы экземпляров могут быть переопределены только если они наследованы подклассом.
	5. Методы, которые объявлены как final, не могут быть переопределены.
	6. Статические методы, которые объявлены как static, не могут быть переопределены, но могут быть повторно объявлены.
	7. Если метод нельзя наследовать, то его нельзя переопределить.
	8. Подкласс внутри того же пакета, что и суперкласс экземпляра, может переопределять любой метод суперкласса, который не объявлен как private или final.
	9. Подкласс в другом пакете может переопределять только не final методы, объявленные как public или protected.
	10. Переопределяемый метод может выдавать любые непроверенные исключения вне зависимости от того, переопределяет ли переопределённый метод какие-либо непроверенные 
		исключения или нет. Однако, переопределяемый метод не должен генерировать проверенные исключения, которые являются новыми или более широкими, чем те, 
		которые объявлены переопределённым методом. Переопределенный метод может генерировать более узкие или меньшие исключения, чем переопределенный метод.
	11. Конструкторы нельзя переопределить.
   Переопределить методы в рамках одного класса нельзя.

18. Ключевое слово final может применяться к классам, методам или полям. 
   В применении к классу оно означает, что данный класс не может иметь наследников.
   В применении к методу оно означает, что данный метод не может быть переопределен в классах наследниках.
   В применении к полю, оно означает, что в каждом конструкторе значение поля должно задаваться только один раз и после этого никогда не может изменяться.
   Поле final является полем, предназначенным только для чтения, и гарантируется, что его параметры задаются только один раз во время построения или во время инициализации 
   класса для static (статических) final полей.
   Применение признака final в объявлениях классов и методов способно повысить уровень безопасности кода. Если класс снабжен модификатором final, никто не в состоянии
   расширить класс и, вероятно, нарушить при этом его контракт. Если признаком final обозначен метод, вы можете полностью доверять его внутренней реализации во всех
   ситуациях, не опасаясь "подделки". Уместно применить final, например, в объявлении метода, предусматривающего проверку пароля, вводимого пользователем, чтобы
   гарантировать точное Исполнение того, что методом предусмотрено изначально. Возможному злоумышленнику не удастся изменить исходную реализацию такого метода,
   "подсунув" программе его переопределенную версию, которая, скажем, всегда возвращает значение true, свидетельствующее об успешной регистрации пользователя,
   независимо от того, какой пароль он ввел на самом деле.
   Применение final в объявлении метода – это верный показатель того, что реализация метода самодостаточна и полностью завершена.

19. Аппарат наследования классов предусматривает возможности преобразования типов между суперклассом и подклассом. Преобразование типов в каком-то смысле является формальным.
   Сам объект при таком преобразовании не изменяется, преобразование относится только к типу ссылки на объект.
   Различаются два вида преобразований типов — upcasting и downcasting . Повышающее преобразование (upcasting) — это преобразование от типа порожденного класса (от подкласса)
   к базовому (суперклассу) или расширение типа. Такое преобразование допустимо всегда. На него нет никаких ограничений и для его проведения не требуется применять никаких
   дополнительных синтаксических конструкций. Это связано с тем, что объект подкласса всегда в себе содержит как свою часть объект суперкласса.
	class Animal {
  		public void doAnimalActions(){}
	}
	class Cat extends Animal {
  		public void doCatActions(){}
	}
	class Tiger extends Cat {
  		public void doTigerActions(){}
	}

	public static void main(String[] args) {
  		Tiger tiger = new Tiger();
  		Cat cat = new Tiger();
  		Animal animal = new Tiger();
  		Object obj = new Tiger();
	}
	Движение вверх по цепочке наследования называется расширением, поскольку оно приводит к более общему типу.
	Но при этом теряется возможность вызвать методы, которые были добавлены в класс при наследовании.
   Понижающее преобразование (downcasting) — это преобразование от суперкласса к подклассу или сужение типа. Такое преобразование имеет ряд ограничений. Во-первых, оно может
   задаваться только явно при помощи операции преобразования типов. Во-вторых, объект, подвергаемый преобразованию, реально должен быть того класса, к которому он преобразуется.
   Если это не так, то возникает исключение ClassCastException в процессе выполнения программы.
	public static void main(String[] args) {
  		Object obj = new Tiger();
  		Animal animal = (Animal) obj;
  		Cat cat = (Cat) obj;
  		Tiger tiger = (Tiger) animal;
  		Tiger tiger2 = (Tiger) cat;
	}
	При сужении типа, нужно использовать оператор преобразования типа, то есть мы выполняем явное преобразование.
	При этом Java-машина выполняет проверку, а действительно ли данный объект унаследован от Типа, к которому мы хотим его преобразовать.

20. В Java почти все сущности являются объектами, за исключением примитивных типов. У каждого объекта есть класс. Сами классы тоже является объектами, и они принадлежат классу Class.
    У класса Class нет публичных конструкторов. Class - это generic тип. Методы Class предназначены для получения информации о классе (объекте типа Class).
    Метод getClass() возвращает класс объекта, содержащий сведения об объекте: public final Class<?> getClass().
	class A{}
	class B extends A{};
	public class Example{
		public static void main(String... args){
			A a = new A();
			A a1 = new A();
			B b = new B();
			A ab = new B();
			System.out.println(a.getClass() == a1.getClass()); // true
			System.out.println(a.getClass() == b.getClass()); // false
			System.out.println(a.getClass() == ab.getClass()); // false
		}
	}
    	Метод прост и эффективен, ровно до тех пор, пока не применен механизм наследования. При наследовании он становится менее полезным.
    Оператор instanceof служит для проверки к какому классу принадлежит объект. a.instanceof B возвращает истину, если в переменной a содержится ссылка на экземпляр класса B,
	подкласс B (напрямую или косвенно, иначе говоря, состоит в иерархии наследования классов) или реализует интерфейс B (так же напрямую или косвенно).
		class A{}
		class B extends A{}
		class C extends A{}
		A aB = new B();
		System.out.println( aB instanceof B ); //true
		System.out.println( aB instanceof A ); //true
		System.out.println( aB instanceof C ); //false

21. Правила переопределения метода equals():
	1. Рефлексивность: Объект должен равняться себе самому.
	2. Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
	3. Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то c.equals(a) тоже должен возвращать true.
	4. Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
		То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
	5. Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false, а не NullPointerException.
		Например, a.equals(null) должен вернуть false.
    Переопределять метод hashCode() не рекомендуется. НО!!! Необходимо переопределить hashCode() в каждом классе, который переопределяет equals(). 
    Невыполнение этого требования приведет к нарушению общего контракта для Object.hashCode(), что будет препятствовать правильному функционированию класса
    в сочетании со всеми коллекциями на основе hash, включая HashMap, HashSet и Hashtable.
    По умолчанию, метод toString() наследуется каждым объектом, произошедшим от объекта Object, он автоматически вызывается, когда объект должен быть представлен
    в строковом контексте, или когда объект участвует в выражении, где ожидается строковое значение. Как правило, метод toString() не вызываются явно,
    а переопределяется в пользовательских объектах, если этот метод не переопределён в пользовательском объекте, то метод toString() возвращает строку следующегов вида:
		"[object тип_объекта]"
    При создании нового класса принято переопределение  toString() таким образом, чтобы возвращающая строка содержала в себе имя класса, имена и значения всех переменных.
    Для вызова метода toString() необходимо просто передать нужный объект в System.out.println. Можно явно вызывать метод toString() - System.out.println(person.toString()),
    но так не принято.

22. Класс, который во время объявления содержит в себе ключевое слово abstract, известен как абстрактный класс.
	1. Абстрактные классы в Java могут содержать или не содержать абстрактные методы, т.е. методы без тела (public void get();)
	2. Если класс имеет хотя бы один абстрактный метод (метод, который не имеет реализации), то класс должен быть объявлен абстрактным.
	3. Если класс объявлен абстрактным, его нельзя реализовать, т.е. на его основе не могут создаваться объекты.
	4. Чтобы использовать абстрактный класс, вам нужно наследовать его из другого класса, обеспечить реализацию абстрактных методов в нём.
	5. Если вы наследуете абстрактный класс в Java, вам нужно обеспечить реализацию всех абстрактных методов в нём.
   Использование абстрактных классов и методов позволяет описать некую абстракцию, которая должна быть реализована в других классах.
   Абстрактные методы не могут содержать тело.
   В абстрактных классах можно определять конструкторы, но они не могут быть абстрактными.
   Абстрактные классы могут содержать неабстрактные методы.
   От абстрактных классов нельзя создавать объекты потому что они абстрактные, в этом и есть их суть.
	
23. Ключевое слово interface используется для создания полностью абстрактных классов. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых
   значений, но не тела методов. Наличие слова interface означает, что именно так должны выглядеть все классы, которые реализуют данный интерфейс. Таким образом, любой код,
   использующий конкретный интерфейс, знает только то, какие методы вызываются для этого интерфейса, но не более того.
   Чтобы создать интерфейс, используйте ключевое слово interface вместо class. Как и в случае с классами, вы можете добавить перед словом interface спецификатор доступа
   public (но только если интерфейс определен в файле, имеющем то же имя) или оставить для него дружественный доступ, если он будет использоваться только в пределах своего
   пакета. Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). Все методы и переменные неявно объявляются как public.
   Класс, который собирается использовать определённый интерфейс, использует ключевое слово implements. Оно указывает, что интерфейс лишь определяет форму, а вам нужно 
   наполнить кодом. Методы, которые реализуют интерфейс, должны быть объявлены как public.
   Интерфейсов у класса может быть несколько, тогда они перечисляются за ключевым словом implements и разделяются запятыми.
   В интерфейсе есть только статические поля, которые не должны инициализироваться при создании объекта в подклассе, а метод интерфейса должен обеспечивать фактическую
   реализацию в подклассе. Поэтому нет необходимости в конструкторе в интерфейсе. Вторая причина - во время создания объекта подкласс вызывается родительский конструктор.
   Когда класс реализует несколько интерфейсов, которые определяют разные конструкторы, класс должен будет реализовать несколько конструкторов, каждый из которых
   удовлетворяет только одному интерфейсу, но не другим. Невозможно построить объект, который вызывает каждый из этих конструкторов.
   При создании объектов класса в качестве типа может указываться имя реализованного в классе интерфейса. Другими словами, если класс реализует интерфейс, то ссылку на
   объект этого класса можно присвоить интерфейсной переменной — переменной, в качестве типа которой указано имя соответствующего интерфейса.

24. Интерфейс Cloneable – это так называемый интерфейс-маркер, который не содержит никаких методов. Он используется, чтобы маркировать (помечать) некоторые классы.
   Если разработчик класса считает, что объекты класса можно клонировать, он помечает класс этим интерфейсом (наследует класс от Cloneable).
   Если разработчика не устраивает стандартная реализация метода clone, он должен написать свою, которая будет создавать дубликат объекта правильным образом.
   При вызове метода clone(), Java проверяет, был ли у объекта интерфейс Cloneable. Если да — клонирует объект методом clone(), если нет — выкидывает исключение CloneNotSupportedException.
	class Point implements Cloneable {
 		int x;
 		int y;

 		public Object clone() {
  			return super.clone();
 		}
	}

25. Интерфейс Comparable содержит один единственный метод int compareTo(E item), который сравнивает текущий объект с объектом, переданным в качестве параметра.
   Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр.
   Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.
		class Person implements Comparable<Person> {     
    			private String name;

			Person(String name) {this.name = name;}
    			String getName() {return name;}
     
			public int compareTo(Person p){
			return name.compareTo(p.getName());
  	  		}
		}
   Однако если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс Comparable, либо реализовал, но нас не устраивает его функциональность,
   и мы хотим ее переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса Comparator<E>.
   Основное свойство Comparator - это использование для сравнения объектов по какому-то конкретному признаку. Компараторы реализуются в 3 видах:
	1. Внешний компаратор.
		public class PersonNameComparator implements Comparator<Person> {     
    			@Override		
			public int compare(Person p1, (Person p2){
				return p1.getName().compareTo(p2.getName());
    			}
		}
	2. Как внутренний статический класс.
		public class Person {     
    			private String name;

			Person(String name) {this.name = name;}
    			String getName() {return name;}

			public static class NameComparator implements Comparator<Person> {
				@Override		
				public int compare(Person p1, (Person p2){
					return p1.getName().compareTo(p2.getName());
    				}
  	  		}
		}
	3. С помощью функционального интерфейса.
		public class FunkComparatorMain {
			public static void main(String[] args) {
				ArrayList<Person> list = new ArrayList<>();
				list.add(new Person(17, "Bob"));
				....

				list.sort((p1, p2) -> p1.getPersonId() - p2.getPersonId());
				list.sort(Comparator.comparing(Person::getName).thenComparing(Person::getPersonId)); //сортировка по 2 параметрам    			
    				}
  	  		}
		}

   Интерфейс Comparable используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
   Т.е. interface Comparable определяет логику сравнения объекта определенного ссылочного типа внутри своей реализации (по правилам разработчика).
   Comparator представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
   Т.е. interface Comparator позволяет создавать объекты, которые будут управлять процессом сравнения (например при сортировках).



Generic classes and Interfaces, Enums

1-2. Кроме отдельных примитивных типов данных и классов в Java есть такой тип как enum или перечисление. Перечисления представляют набор логически связанных констант.
   Объявление перечисления происходит с помощью оператора enum, после которого идет название перечисления. Затем идет список элементов перечисления через запятую:
		enum Day{ 
			MONDAY,
			TUESDAY,
			WEDNESDAY,
			THURSDAY,
			FRIDAY,
			SATURDAY,
			SUNDAY
		}
   Перечисление фактически представляет новый тип, поэтому мы можем определить переменную данного типа и использовать ее:
		public class Program {      
			public static void main(String[] args) {          
				Day current = Day.MONDAY; // в этот момент инициализируются все перечисления
				Day current1 = Day.valueOf("SUNDAY");
				System.out.println(current + " " + current1);    // MONDAY SUNDAY
			}
		}
   Enum — это настоящий класс со всеми вытекающими из этого возможностями. Например, если текущей реализации дней недели недостаточно, ты можно добавить в DayOfWeek
   переменные, конструкторы и методы. Следует отметить, что конструктор по умолчанию приватный, то есть имеет модификатор private. Любой другой модификатор будет считаться
   ошибкой. Поэтому создать константы перечисления с помощью конструктора мы можем только внутри перечисления.
   По сравнению с обычными классами, на Enum наложили одно серьезное ограничение — от него невозможно наследоваться.
   У перечислений есть характерные только для них методы:
	values() - возвращает массив из всех хранящихся в Enum значений;
	ordinal() - возвращает порядковый номер константы. Отсчет начинается с нуля;
	valueOf() - возвращает объект Enum, соответствующий переданному имени;
	compareTo() - сравнивает порядковые значения констант одного и того же перечисления;
	метод equals() - сравнивает значения перечислений по ссылкам (потому что значения в перечислениях являются константными);
	hashCode() - использует стандартную реализацию из класса Object.
   Все элементы перечисления существуют в единственном экземпляре, это контролируется на уровне виртуальной машины. Поэтому их можно сравнивать напрямую, по ссылкам.

3. Анонимные классы декларируются внутри методов основного класса и могут быть использованы только внутри этих методов. В отличие от локальных классов,
   анонимные классы не имеют названия. Главное требование к анонимному классу - он должен наследовать существующий класс или реализовывать существующий интерфейс.
   Анонимные классы не могут содержать определение статических полей, методов и классов (кроме констант), но могут их наследовать
   Анонимный класс — это полноценный внутренний класс. Поэтому у него есть доступ к переменным внешнего класса, в том числе к статическим и приватным.

4. Параметризированные (generic) типы - классы, интерфейсы и методы, в которых тип обрабатываемых данных задается как параметр (параметр типа).
   Параметризированные типы, позволяют использовать более гибкую и в то же время достаточно строгую типизацию, обеспечивая безопасность типов.
   Применение параметров позволяет ограничить тип данных, которые могут использоваться в коллекциях. Это ограничение позволяет расширить возможности коллекции при обработке
   этого типа данных.
		class Person {
    			private int personId;
    			private String name;

    			public Person() {}
			.....
		}

		class Student extends Person {
    			private String faculty;
    			private  int yearOfStudy;
			.....
		}

		public class People {

    			public static void main(String[] args) {
        			List<Student> list = new ArrayList<>(); // параметр Student
        			list.add(new Student());
        			list.add(new Student());
        			list.add("new");        // можно добавить только Student
        			list.add(new Person()); // или объект дочернего класса
        			Student student = list.get(1);
    			}
		}

   Применение параметров обеспечивает типобезопасность.
   Аргумент типа, задаваемый при объявлении параметризированного типа – может быть только классом, а не примитивным типом !!!

   

Exceptions and Errors

1. Исключение – это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
	1. Пользователь ввел некорректные данные.
	2. Файл, к которому обращается программа, не найден.
	3. Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.
   Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.
   В Java есть пять ключевых слов для работы с исключениями:
	try – данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
	catch – ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
	finally – ключевое слово для отметки начала блока кода, которой является дополнительным. Этот блок помещается после последнего блока ‘catch’. Управление обычно передаётся в блок ‘finally’ в любом случае.
	throw – служит для генерации исключений.
	throws – ключевое слово, которое прописывается в сигнатуре метода, и обозначающее что метод потенциально может выбросить исключение с указанным типом.
   Общий вид конструкции для "поимки" исключительной ситуации выглядит следующим образом:
	try{ 
		//здесь код, который потенциально может привести к ошибке 
	} 
	catch(SomeException e ){ //в скобках указывается класс конкретной ожидаемой ошибки  
		//здесь описываются действия, направленные на обработку исключений 
	} 
	finally{ 
		//выполняется в любом случае ( блок finally  не обязателен) 
	}

2. Исключительная ситуация (exception) – это любая ошибка или ошибочное условие, возникающее в процессе выполнения программы. Когда программа обнаруживает ошибку, она генерирует
   исключительную ситуацию. При этом нормальный ход выполнения программы прерывается, и управление передается специальной части кода, которая выполнят обработку этой исключительной
   ситуации. После обработки исключительной ситуации возврат в точку ее возникновения не происходит, а выполняются действия, следующие за телом обработчика.
   Системные исключения генерируются автоматически. А для того чтобы сгенерировать исключение вручную, следует воспользоваться ключевым словом throw.

3. В Java все исключения представлены отдельными классами. Все классы исключений являются потомками класса Throwable. Так, если в программе возникнет исключительная ситуация,
   будет сгенерирован объект класса, соответствующего определенному типу исключения. У класса Throwable имеются два непосредственных подкласса: Exception и Error.   
   Исключительные ситуации, возникающие в программе, можно разделить на две группы: 
   1. Ситуации, при которых восстановление дальнейшей нормальной работы программы невозможно.
	К этой группе относят ситуации, когда возникают исключения, унаследованные из класса Error. Это ошибки, возникающие при выполнении программы в результате сбоя работы JVM,
   	переполнения памяти или сбоя системы. Обычно они свидетельствуют о серьезных проблемах, устранить которые программными средствами невозможно. Такой вид исключений в Java
   	относится к неконтролируемым (unchecked) на стадии компиляции.
	К этой группе также относят RuntimeException – исключения, наследники класса Exception, генерируемые  JVM во время выполнения программы. Часто причиной возникновения их
	являются ошибки программирования. Эти исключения также являются неконтролируемыми (unchecked) на стадии компиляции, поэтому написание кода по их обработке не является обязательным.
   2. Восстановление возможно.
	Ко этойгруппе относят исключительные ситуации, предвидимые еще на стадии написания программы, и для которых должен быть написан код обработки. Такие исключения являются
	контролируемыми (checked). Основная часть работы разработчика на Java при работе с исключениями – обработка таких ситуаций.

4. Основными языковыми средствами обработки исключений являются ключевые слова try и catch. Они используются совместно. Это означает, что нельзя указать ключевое слово catch в коде,
   не указав ключевое слово try. 
	try {
    		// Блок кода, в котором должны отслеживаться ошибки
	}
	catch (тип_исключения_1 объект_исключения) {
    		// Обработчик исключения тип_исключения_1
	}
	catch (тип_исключения_2 объект_исключения) {
    		// Обработчик исключения тип_исключения_2
	}
	finally{ 
		//выполняется в любом случае ( блок finally  не обязателен) 
	}
   В скобках, следующих за ключевым словом catch, указываются тип исключения и переменная, ссылающаяся на объект данного типа. Когда возникает исключение, оно перехватывается
   соответствующим оператором catch, обрабатывающим это исключение. Как следует из приведенной выше общей формы записи, с одним блоком try может быть связано несколько операторов
   catch. Тип исключения определяет, какой именно оператор catch будет выполняться. Так, если тип исключения соответствует типу оператора catch, то именно он и будет выполнен,
   а остальные операторы catch — пропущены. При перехвате исключения переменной, указанной в скобках после ключевого слова catch, присваивается ссылка на объект_исключения.
   Следует иметь в виду, что если исключение не генерируется, блок try завершается обычным образом и ни один из его операторов catch не выполняется. Выполнение программы
   продолжается с первого оператора, следующего за последним оператором catch. Таким образом, операторы catch выполняются только при появлении исключения.
   При использовании множественных операторов catch обработчики подклассов исключений должные находиться выше, чем обработчики их суперклассов. Иначе, суперкласс будет перехватывать
   все исключения, имея большую область перехвата. Иными словами, например, Exception не должен находиться выше ArithmeticException и ArrayIndexOutOfBoundsException.
   Операторы try могут быть вложенными. Если вложенный оператор try не имеет своего обработчика catch для определения исключения, то идёт поиск обработчика catch у внешнего блока try и т.д.
   Блок try можно вложить в catch, в finally нельзя (кроме случая, когда он принадлежит отдельной цепочке try-catch).
   Трассировка стека предоставляет информацию об истории выполнения текущего потока и перечисляет имена классов и методов, которые вызвали в точке, когда исключение произошло.
   Трассировка стека является полезным средством отладки, которое Вы будете обычно использовать в своих интересах, когда исключение было выдано.
   «try c ресурсами» это оператор try, в котором объявляются один или несколько ресурсов. Ресурс — это объект, который должен быть закрыт после того, как программа закончит
   с ним работу. «try c ресурсами» берет всю работу по закрытию ресурсов на себя. Главное отличие от привычного блока try в круглых скобках, в которых создаются ресурсы,
   которые впоследствии нужно закрыть, ресурсы будут закрываться снизу-вверх автоматически после завершения работы блока try, т.е. в примере, сначала закроется writer, а потом reader.
		try(BufferedReader reader = Files.newBufferedReader(path1);
                	BufferedWriter writer = Files.newBufferedWriter(path2)){
            		// блок try
        		} catch(IOException){
            		// блок catch
        		} finally{
            		// блок finally
        	}

5. При использовании множественных операторов catch обработчики подклассов исключений должные находиться выше, чем обработчики их суперклассов. Иначе, суперкласс будет перехватывать
   все исключения, имея большую область перехвата. Иными словами, например, Exception не должен находиться выше ArithmeticException и ArrayIndexOutOfBoundsException.
   Перехваченное исключение может появиться снова только если его сгенерировать вручную.
   Исключение, перехваченное блоком catch, может быть повторно сгенерировано для обработки другим аналогичным блоком. Чаще всего повторное генерирование исключений применяется с
   целью предоставить разным обработчикам доступ к исключению. Так, например, повторное генерирование исключений имеет смысл в том случае, когда один обработчик оперирует одним
   свойством исключения, а другой опенрирован на другое его свойство. Повторно сгенерированное исключение не может быть перехвачено тем же самым блоком catch. Оно распространяется
   на следующий.

6. В случае, когда необходимо гарантировано выполнить определенный участок кода необходимо использовать ключевое слово finally. Использование связи try...finally позволяет
   обеспечить выполнение кода независимо от того, какие исключения были возбуждены и перехвачены, даже в тех случаях, когда в методе нет соответствующего возбужденному исключению
   раздела catch.
   У каждого раздела try должен быть по крайней мере или один раздел catch или блок finally. Блок finally очень удобен для закрытия файлов и освобождения любых других ресурсов,
   захваченных для временного использования в начале выполнения метода. Блок finally почти всегда. Код в finally не выполнится, если упала JVM или прервался поток, в котором
   он написан. Ну, или JVM достигает бесконечного цикла (или некоторого другого не прерываемого, не завершающего оператора) в блоке try-catch.
   Блок finally может выбрасывать исключения, если какой-то "умник" всунет туда catch или return.
   Блок finally не может выполнится дважды.

