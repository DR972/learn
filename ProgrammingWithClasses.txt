Programming with classes

1. Инициализация (от англ. initialization - инициирование) - создание, активация, подготовка к работе, определение параметров.
   Порядок инициализации:
	инициализации статических переменных (полей) класса-предка;
	инициализации статических переменных (полей) класса-потомка;
	инициализации нестатических переменных (экземпляров класса) класса-предка;
	инициализации нестатических полей (экземпляров класса) класса-потомка.
   Типы инициализации полей класса:
	инициализация в месте объявления;
	инициализация в статическом блоке;
	инициализация в методах.
   Типы инициализации полей экземпляра класса:
	инициализация в месте объявления;
	инициализация в нестатическом блоке;
	инициализация через конструктор;
	инициализация в методах.
   Всем числовым переменным по умолчание присваивается '0', переменной char - ' '(нуль-символ), переменной boolean  - 'false', ссылочным переменным - 'null'.   

2. Перегрузка (от англ. overloading) - использование одного идентификатора для ссылки на разные элементы в одной области действия.
   Перегрузка методов — это приём программирования, который позволяет разработчику в одном классе для методов с разными параметрами использовать одно и то же имя.
   В этом случае говорят, что метод перегружен. Каждый перегруженный метод должен иметь уникальный список типов аргументов.
   Главная ценность перегрузки заключается в том, что она обеспечивает доступ к группе родственных методов по общему имени.
   Использование перегрузки делает код чище и проще для чтения, а также помогает избежать ошибок в программе.
   Статические методы могут перегружаться нестатическими и наоборот – без ограничений.
   Перегрузка метода определяет несколько методов в одном классе, которые принимают разные числа и типы параметров. Перегрузка возможна также из базового класса.
   Перегрузка конструкторов реализуется так же, как и перегрузка методов. Перегрузка конструкторов позволяет установить различные способы начальной инициализации объектов класса.
   При перегрузке конструкторов менять атрибуты доступа у конструкторов нельзя?

3. Возможность связать конкретный вызов метода с телом метода называется связыванием.
   Раннее связывание - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода.
   Позднее связывание - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.
   Перегрузка – это раннее связывание.
   Правила перегрузки методов:
	1. Список параметров должен быть разным.
	2. Статический тип должен быть разным.
	3. Расширяющее преобразование примитивов имеет приоритет над автоупаковкой/распаковкой.
	4. Автоупаковка/распаковка имеет приоритет перед методом с переменным количеством аргументов.
	5. Сужающее преобразование примитивов автоматически НЕ выполняется.

4. Ключевое слово this используется для ссылки на текущий экземпляр метода, в котором он используется. Способы его использования:
	1. Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена, чтобы конкретно обозначить, что переменная экземпляра 
		используется вместо статической или локальной переменной:
			private String javaFAQ;
			void methodName(String javaFAQ) {
    				this.javaFAQ = javaFAQ;
			}
	2. Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого:
			Human(int age, int weight){
        			this.age = age;
        			this.weight = weight;
    			}
    			Human(int age, int weight, int height){
				this(age, weight);
				this.height = height;
			}
	3. Для передачи текущего экземпляра java в качестве параметра:
			obj.itIsMe(this);
	4. Может быть использовано для возврата текущего экземпляра:
			CurrentClassName startMethod() {
     				return this;
			}
	5. This можно использовать для получения дескриптора текущего класса:
			Class className = this.getClass();
   Ключевое слово this представляет собой неявно определенный указатель на сам объект. С его помощью метод класса определяет, с данными какого объекта ему предстоит работать.
   По идеи оно должно присутствовать перед каждым объектом в методе, но это очень неудобно. Поэтому за нас это делает компилятор.

5. Ключевое слово final может применяться к классам, методам или полям. 
   В применении к классу оно означает, что данный класс не может подразделяться на подклассы. 
   В применении к методу оно означает, что данный метод не может быть заменен каким-либо подклассом. 
   В применении к полю, оно означает, что в каждом конструкторе значение поля должно задаваться только один раз и после этого никогда не может изменяться.
   Поле final является полем, предназначенным только для чтения, и гарантируется, что его параметры задаются только один раз во время построения или во время инициализации 
   класса для static (статических) final полей.   

6. Поле данных, объявленное в классе как static, является общим для всех объектов класса и называется переменной класса. Если один объект изменит значение такого поля,
   то это изменение увидят все объекты. Применив определение final к статической переменной получим константу, что очень удобно.
   Статические методы отличаются от обычных тем, что они также привязаны к классу, а не к объекту. 
   Важным свойством статического метода является то, что он может обратиться только к статическим переменным/методам.
   Переопределение статических методов класса не имеет практического смысла, так как обращение к статическому атрибуту или методу осуществляется по большей части 
   посредством задания имени класса, которому они принадлежат.
   Статические методы могут быть перегружены нестатическими, как было указано в п.2.
   Статические методы в Java наследуются, но не могут быть переопределены. Если вы объявляете тот же метод в подклассе, вы скрываете метод суперкласса вместо его переопределения.
   Статические методы не являются полиморфными. Во время компиляции статический метод будет статически связан.

7. Есть два блока инициализации — обычный и статический.
   Блок предназначен для инициализации внутренних переменных. Если блок обычный, то им инициализируют внутренние переменные объекта, если же не статический, соответственно,
   им задают статические переменные (то есть переменные класса).
   Статический блок в java выполняется перед основным методом. Их может сколько угодно и располагаться могут в любом месте класса.
   Обычный блок должен быть расположен перед созданием объекта.

8. Возникают ситуации, когда заранее неизвестно количество передаваемых экземпляров класса в метод. В обычной ситуации пришлось бы создавать несколько перегруженных методов
   с разным числом параметров одного типа. Другим решением будет один метод с параметром в виде массива или коллекции.В методах этого типа список параметров имеет
   не фиксированную, а переменную длину.
			static void test(int... array) {}
   Это объявление сообщает компилятору, что метод test() может вызываться с указанием произвольного количества аргументов или без них. Оно также означает неявное
   объявление аргумента array в виде массива int[]. Помимо списка параметров переменной длины, в объявлении метода могут быть указаны и обычные параметры при условии:
   список параметров переменной длины можно указать только один раз и он должен быть указан последним.
   Дальнейшая работа с этими методами аналогична работе с обычными методами.

9. В Java определен один специальный класс, называемый Object. Все остальные классы являются подклассами, производными от этого класса,
   даже если в объявлении это явно не указано. В классе Object определен ряд методов, которые доступны всем классам языка Java.
   Методы класса Object в Java:
	1. protected Object clone() - создает новый объект, не отличающийся от клонируемого;
	2. protected void finalize() - вызывается перед удалением неиспользуемого объекта;
	3. public final Class<?> getClass() - получает класс объекта во время выполнения;
	4. public int hashCode() - возвращает хэш-код, связанный с вызывающим объектом;
	5. public final void notify() - возобновляет исполнение потока, ожидающего вызывающего объекта;
	6. public final void notifyAll() - возобновляет исполнение всех потоков, ожидающих вызывающего объекта;
	7. public String toString() - возвращает символьную строку, описывающую объект;
	8. public final void wait() - ожидает другого потока исполнения;
	9. public final void wait(long timeout) - ожидает другого потока исполнения;
	10. public final void wait(long timeout, int nanos) - ожидает другого потока исполнения.

10. Хэш-функция, которая представлена в Java  методом hashCode(), возвращает числовое значение фиксированной длины для любого объекта.
    В случае с Java метод hashCode() возвращает для любого объекта 32-битное число типа int.     
    Если надо сравнивать объекты, гораздо проще сделать это по хэш-коду, и только если они равны по hashCode() — переходить к сравнению по equals().
    Для метода hashCode() есть официальные требования, прописанные в документации Oracle:
	1. Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.
	2. Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число.
	3. Правило 1 не работает в обратную сторону. Одинаковый хэш-код может быть у двух разных объектов.
    Ситуация, когда два разных объекта могут сгенерировать одинаковые хэш-коды называется коллизией.
    Например, если хешировать целые числа и хеширующая функция просто (n % 10) то число 17 и число 27 приведут к одинаковому результату. Это не значит, что эти цифры одинаковы.
    Поэтому, после если два объекта равны по hashCode() — переходим к сравнению по equals().

11. В Java почти все сущности являются объектами, за исключением примитивных типов. У каждого объекта есть класс. Сами классы тоже является объектами, и они принадлежат классу Class.
    У класса Class нет публичных конструкторов. Class - это generic тип. Методы Class предназначены для получения информации о классе (объекте типа Class).
    Метод getClass() возвращает класс объекта, содержащий сведения об объекте: public final Class<?> getClass().
	class A{}
	class B extends A{};
	public class Example{
		public static void main(String... args){
			A a = new A();
			A a1 = new A();
			B b = new B();
			A ab = new B();
			System.out.println(a.getClass() == a1.getClass()); // true
			System.out.println(a.getClass() == b.getClass()); // false
			System.out.println(a.getClass() == ab.getClass()); // false
		}
	}
    	Метод прост и эффективен, ровно до тех пор, пока не применен механизм наследования. При наследовании он становится менее полезным.
    Оператор instanceof служит для проверки к какому классу принадлежит объект. a.instanceof B возвращает истину, если в переменной a содержится ссылка на экземпляр класса B,
	подкласс B (напрямую или косвенно, иначе говоря, состоит в иерархии наследования классов) или реализует интерфейс B (так же напрямую или косвенно).
		class A{}
		class B extends A{}
		class C extends A{}
		A aB = new B();
		System.out.println( aB instanceof B ); //true
		System.out.println( aB instanceof A ); //true
		System.out.println( aB instanceof C ); //false
    
12. Правила переопределения метода equals():
	1. Рефлексивность: Объект должен равняться себе самому.
	2. Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
	3. Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то c.equals(a) тоже должен возвращать true.
	4. Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.
		То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
	5. Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false, а не NullPointerException.
		Например, a.equals(null) должен вернуть false.
    Переопределять метод hashCode() не рекомендуется. НО!!! Необходимо переопределить hashCode() в каждом классе, который переопределяет equals(). 
    Невыполнение этого требования приведет к нарушению общего контракта для Object.hashCode(), что будет препятствовать правильному функционированию класса
    в сочетании со всеми коллекциями на основе hash, включая HashMap, HashSet и Hashtable.
    По умолчанию, метод toString() наследуется каждым объектом, произошедшим от объекта Object, он автоматически вызывается, когда объект должен быть представлен
    в строковом контексте, или когда объект участвует в выражении, где ожидается строковое значение. Как правило, метод toString() не вызываются явно,
    а переопределяется в пользовательских объектах, если этот метод не переопределён в пользовательском объекте, то метод toString() возвращает строку следующегов вида:
		"[object тип_объекта]"
    При создании нового класса принято переопределение  toString() таким образом, чтобы возвращающая строка содержала в себе имя класса, имена и значения всех переменных.
    Для вызова метода toString() необходимо просто передать нужный объект в System.out.println. Можно явно вызывать метод toString() - System.out.println(person.toString()),
    но так не принято.
