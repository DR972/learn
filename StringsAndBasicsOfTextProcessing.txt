Home Task Strings and basics of text processing. Questions.


1. Объекты типа String создаются таким же образом, как и объекты других типов.
	String str1 = new String("Hello World!");
	String str2 = "Hello World!";
	String str3 = new String(str2);
	char[] ch = {'e', 'f', 's'};	String str4 = new String(ch);
	String str5 = "Hello" + 3;
   Конструкторы класса String:
	String() - инициализирует объект, представляющий собой пустую последовательность символов.
	String(byte[] bytes) - создаёт новый объект, расшифровывающий указанный массив bytes, используя кодировку платформы по умолчанию.
	String(byte[] bytes, Charset charset) - создаёт новый объект, расшифровывая указанный массив bytes с использованием заданной кодировки charset.
	String(byte[] ascii, int hibyte) - неправильно преобразовывает байты в символы. Вместо него предпочтительно использовать конструкторы,
		которые принимают название кодировки или используют кодировку по умолчанию.
	String(byte[] bytes, int offset, int length) - создаёт новую строку посредством раскодировки заданного подмассива байтов, используя кодировку платформы по умолчанию.
	String(byte[] bytes, int offset, int length, Charset charset) - создаёт новую строку посредством раскодировки заданного подмассива байтов, используя указанную кодировку.
	String(byte[] ascii, int hibyte, int offset, int count) - неправильно преобразовывает байты в символы. Вместо него предпочтительно использовать конструкторы,
		которые принимают название кодировки или используют кодировку по умолчанию.
	String(byte[] bytes, int offset, int length, String charsetName) - создаёт новую строку посредством раскодировки заданного подмассива байтов, используя указанную кодировку.
	String(byte[] bytes, String charsetName) - создаёт новую строку посредством раскодировки заданного массива байтов, используя указанную кодировку.
	String(char[] value) - выделяет новую строку, так, что она представляет собой последовательность символов, содержащихся в массиве типа char.
	String(char[] value, int offset, int count) - выделяет новую строку, которая содержит символы из подмассива массива типа char.
	String(int[] codePoints, int offset, int count) - выделяет новую строку, которая содержит символы из подмассива массива кодовых точек Юникода.
	String(String original) - инициализирует только что созданный объект так, что он представляет собой ту же последовательность символов, что и аргумент.
		Иными словами, вновь созданная строка является копией аргумента.
	String(StringBuffer buffer) - выделяет новую строку, содержащую последовательность символов, и находящуюся в аргументе buffer.
	String(StringBuilder builder) - выделяет новую строку, содержащую последовательность символов, и находящуюся в аргументе builder.
   Строковый литерал — последовательность символов заключенных в двойные кавычки. 
   Проще всего создать экземпляр класса String, присвоив ему значение строкового литерала: String str2 = "Hello World!";

2. Класс String — immutable класс, то есть его объекты не могут быть изменены после создания. Любые операции над объектом String,
   результатом которых должен быть объект класса String, приведут к созданию нового объекта.
   Класс String - это финальный класс, который не может иметь потомков.
   String широко используется , как параметр для многих классов Java, в частности для открытия сетевых соединений, подключений к Базам данных, открытию файлов и пр.
   И если бы строка изменялась, то мы могли получить доступ к объекту (файлу например), на который мы имеем право, затем изменить строку с именем (случайно или намеренно)
   и получить доступ уже к другому файлу.

3. В вычислительных машинах символы не могут храниться иначе, как в виде последовательностей бит (как и числа). Для передачи символа и его корректного отображения
   ему должна соответствовать уникальная последовательность нулей и единиц или код. Для этого были разработаны таблицы кодировок.
   Кодировкой называется набор символов и соответствующий им набор кодов. И таких кодировок придумали много.
	ASCII - таблицы кодировок, в которых содержатся основные символы (английский алфавит, цифры, знаки препинания, символы национальных алфавитов(свои для каждого региона),
	служебные символы) и длина кода каждого символа n=8 бит.
		КОИ8-R — первая русская кодировка. Символы кириллицы расположены не в алфавитном порядке.
		CP866 — русская кодировка, использовавшаяся на компьютерах IBM в системе DOS.
		Windows-1251 — русская кодировка, использовавшаяся в русскоязычных версиях операционной системы Windows в начале 90-х годов.
	Юникод (Unicode) — это промышленный стандарт обеспечивающий цифровое представление символов всех письменностей мира, и специальных символов.
		UTF-8 — представление Юникода, обеспечивающее наибольшую компактность и обратную совместимость с 7-битной системой ASCII;
			текст, состоящий только из символов с номерами меньше 128, при записи в UTF-8 превращается в обычный текст ASCII и может быть отображён любой программой,
			работающей с ASCII; и наоборот, текст, закодированный 7-битной ASCII может быть отображён программой, предназначенной для работы с UTF-8.
			Остальные символы Юникода изображаются последовательностями длиной от 2 до 4 байт, в которых первый байт всегда имеет маску 11xxxxxx, а остальные — 10xxxxxx.
		UTF-16 — символы представлены двумя байтами (16 битами). Эта кодировка используется в Windows, поскольку 16-битными значениями можно представить символы,
			составляющие алфавиты большинства языков мира, это позволяет программам быстрее обрабатывать строки и вычислять их длину.
			Однако для представления символо алфавита некоторых языков 16 бит недостаточно.
			Для таких случаев UTE-16 поддерживает «суррогатные» кодировки, позволяющие кодировать символы 32 битами (4 байтами). 
		UTF-32 — символы представлены 4 байтами. Эта кодировка удобна для написания простых алгоритмов для перебора символов любого языка, не требующих обработки символов,
			представленных разным числом байтов. Например, при использовании UTF-32 можно забыть о «суррогатах», поскольку любой символ в этой кодировке представлен
			4 байтами. Ясно, что с точки зрения использования памяти эффективность UTF-32 далека от идеала. Поэтому данную кодировку редко применяют для передачи
			строк по сети и сохранения их в файлы. Как правило, UTF-32 используется как внутренний формат представления данных в программе.
	В Java строки -- в Unicode. Всегда. Значит перекодировать строку нельзя. Можно только раскодировать поток байтов в строчку, или закодировать строчку в поток байтов.
		Charset cset = Charset.forName("UTF-8");
		ByteBuffer buf = cset.encode(stroka);
		byte[] b = buf.array();
		String str = new String(b);
	 и обратно
		ByteBuffer buff = ByteBuffer.wrap(str.getBytes());
		CharBuffer chbuf = cset.decode(buff);
		String start = chbuf.toString();

4. Для литералов типа строка есть Пул литералов. Пул строк (String Pool) — это множество строк в куче (Java Heap Memory). В Пуле литералов объект может содержаться только
   в единственном экземпляре. Если существует несколько строк и они имеют одинаковые значения в разных частях приложения, то все ссылки будут ссылаться на один объект
   и находиться он будет в Пуле. Когда мы используем двойные кавычки, чтобы создать новую строку, то первым делом идет поиск строки с таким же значением в пуле строк. 
   Если java такую строку нашла, то возвращает ссылку, в противном случае создается новая строка в пуле, а затем возвращается ссылка. 
   Однако использование оператора new заставляет класс String создать новый объект String. 
   После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк или получить из пула ссылку на другой объектString с таким же значением.
	String c = b.intern();
   До Java 7 JVM помещал пул Java String в пространство PermGen, которое имеет фиксированный размер - его нельзя развернуть во время выполнения и не подходит для сборки мусора.
   Риск интернирования Strings в PermGen (вместо Heap) заключается в том, что мы можем получить ошибку OutOfMemory от JVM, если мы интернируем слишком много Strings .
   Начиная с Java 7, пул Java String хранится в пространстве Heap, которое собирает мусор с помощью JVM.
   Преимущество этого подхода заключается в уменьшенном риске ошибки OutOfMemory, поскольку несвязанные Strings будут удалены из пула, тем самым освобождая память.

5. Объекты String являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, что сказывается на производительности приложения.
   Для решения этой проблемы, чтобы работа со строками проходила с меньшими издержками в Java были добавлены классы StringBuffer и StringBuilder.
   По сути они напоминает расширяемую строку, которую можно изменять без ущерба для производительности.
   Эти классы похожи, практически двойники, они имеют одинаковые конструкторы, одни и те же методы, которые одинаково используются. Единственное их различие состоит в том,
   что класс StringBuffer синхронизированный и потокобезопасный. Т.е. класс StringBuffer удобнее использовать в многопоточных приложениях, где объект данного класса может
   меняться в различных потоках. Если же речь о многопоточных приложениях не идет, то лучше использовать класс StringBuilder, который не потокобезопасный,
   но при этом работает быстрее, чем StringBuffer в однопоточных приложениях.
   Внутри класса String метод equals переопределён, а в классе StringBuilder нет, поэтому можно сравнивать строки по ЗНАЧЕНИЮ с помощью equals.
	System.out.println(sb1.toString().equals(sb2.toString())); или
	System.out.println(sb1.toString().contentEquals(sb2)); 

6. см. 3.

7. Строка (String) — это последовательная коллекция символов (char), которая используется для представления текста. 
   StringОбъект — это последовательная коллекция System.Char объектов, представляющих строку; System.Char объект соответствует блоку кода UTF-16.
    Кодовая точка - это число, которое идентифицирует символ. Вса методы класса String используют для работы кодовые точки. Например:
	Метод length() возвращает количество кодовых единиц для данной строки в кодировке UTF-16.
	Метод s.charAt(n) возвращает кодовую единицу в позиции n, где n находится в интервале от 0 до s.length() - 1.


 
Regular Expressions


1. Регулярное выражение (RegEx) – это шаблон для поиска строки в тексте. В Java исходным представлением этого шаблона всегда является строка, то есть объект класса String.
   Однако не любая строка может быть скомпилирована в регулярное выражение, а только та, которая соответствует правилам написания регулярного выражения – синтаксису,
   определенному в спецификации языка.
   Для написания регулярного выражения используются буквенные и цифровые символы, а также метасимволы – символы, имеющие специальное значение в синтаксисе регулярных выражений.
   Квантификаторы — это метасимволы, позволяющие задать количество повторений символа или группы символов в строке.
   Синтаксис регулярных выражений основан на использовании символов <([{\^-=$!|]})?*+.>, которые можно комбинировать с буквенными символами. Их можно разделить на группы:
	1. Метасимволы для поиска совпадений границ строк или текста:
		^	начало строки (якорь)
		$	конец строки (якорь)
		\b	граница слова
		\B	не граница слова
		\A	начало ввода
		\G	конец предыдущего совпадения
		\Z	конец ввода
		\z	конец ввода
	2. Метасимволы для поиска символьных классов:
		\d	цифровой символ
		\D	нецифровой символ
		\s	символ пробела
		\S	непробельный символ
		\w	буквенно-цифровой символ или знак подчёркивания
		\W	любой символ, кроме буквенного, цифрового или знака подчёркивания
		.	любой символ
	3. Метасимволы для поиска символов редактирования текста:
		\t	символ табуляции
		\n	символ новой строки
		\r	символ возврата каретки
		\f	переход на новую страницу
		\u 0085	символ следующей строки
		\u 2028	символ разделения строк
		\u 2029	символ разделения абзацев
	4. Метасимволы для группировки символов:
		[абв]		любой из перечисленных (а,б, или в)
		[^абв]		любой, кроме перечисленных (не а,б, в)
		[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )
		[a-d[m-p]]	объединение символов (от a до d и от m до p)
		[a-z&&[def]]	пересечение символов (символы d,e,f)
		[a-z&&[^bc]]	вычитание символов (символы a, d-z)
	5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов:
		?	один или отсутствует
		*	ноль или более раз
		+	один или более раз
		{n}	n раз
		{n,}	n раз и более
		{n,m}	не менее n раз и не более m раз
   Java Regex API поддерживает набор логических операторов, которые можно использовать для объединения нескольких подшаблонов в одном регулярном выражении оператор and и оператор or.
   Нет символов - and, | - or, (XY) - используется, как отдельная группа.
   Якорь – определяет позицию шаблона в строке текста (^ – начало строки; $ – конец строки - в том случае, если они являются самым первым и самым последним символами шаблона.
   Иначе эти символы становятся литералами (представляют сами себя). Начало строки — это символ нулевой ширины, который находится непосредственно перед первым символом,
   а конец строки — это символ нулевой ширины, который находится сразу после точки(последнего символа). 
   Под «нулевой шириной» подразумевается, что при написании эти символы не отображаются. Они есть, но мы не можем их видеть.

2. Регулярные выражения в Java обеспечиваются пакетом java.util.regex. В пакете java.util.regex ключевыми являются 3 класса:
	Pattern Class – объект класса Pattern представляет скомпилированное представление регулярного выражения. В классе Pattern публичный конструктор не предусмотрен.
		Для создания шаблона, вначале необходимо вызвать один из представленных публичных статичных методов compile(), который далее произведет возврат объекта класса Pattern.
		Регулярное выражение в данных методах принимается как первый аргумент.
	Matcher Class – объект класса Matcher представляет механизм, который интерпретирует шаблон, а также производит операции сопоставления с вводимой строкой.
		Аналогично классу Pattern, Matcher не содержит публичных конструкторов. Объект класса Matcher может быть получен путем вызова метода matcher() на объекте класса Pattern.
	PatternSyntaxException – объект класса PatternSyntaxException представляет непроверяемое исключение, которое обозначает синтаксическую ошибку в шаблоне регулярного выражения.
   Java Regex API поддерживает набор логических операторов, которые можно использовать для объединения нескольких подшаблонов в одном регулярном выражении оператор and и оператор or.
	public String[] splitParagraphs(String text) {
        return text.split("\n");			создание массива абзацев
    }

    public String[] splitSentences(String text) {
        return text.split("\\.*[.!?]\\s*");		создание массива предложений
    }

    public String[] splitWords(String sentence) {
        return sentence.split("\\s*(\\s|,|;|:)\\s*");	создание массива слов
    }
	import java.util.regex.*;
	public class Main {
    		public static void main(String[] args) {
        		String text = "then, when you have found the shrubbery, you must cut down " +
                		"the mightiest tree in the forest... with... a herring!";
        		String the = "the";
        		String you = "you";
        		StringBuilder newText = new StringBuilder();
        		Pattern pThe = Pattern.compile(the);				создание объекта pThe класса Pattern
        		Pattern pYou = Pattern.compile(you);				создание объекта pYou класса Pattern
        		String[] lines = text.split("\\s*(\\s|,|;|:)\\s*");		создание массива слов
        		for (String line : lines) {
            			Matcher mThe = pThe.matcher(line);			метод Matcher ищет совпадения с объектом pThe.matcher
            			Matcher mYou = pYou.matcher(line);			метод Matcher ищет совпадения с объектом pYou.matcher
            			if (mThe.find()) {
					newText.append(mThe.group()).append(" ");	mетод group() возвращает символы предыдущего найденного совпадения
				}
            			if (mYou.find()) {					vетод boolean find() ищет во входном тексте следующее совпадение.
					newText.append(mYou.group()).append(" ");
				}
        		}
        	System.out.print(newText.toString());
   		}
	}

3. Группы представляют собой части регулярного выражения, заключенные в круглые скобки, к которым позже можно обращаться по номеру группы.
   Группа 0 соответствует совпадению всего выражения, группа 1 - совпадению первого выражения в круглых скобках и т.д.
	A(B(C))D	0 - ABCD,	1 - BC,		2 - C.